1. 纸上写了一个单调非递减的数字序列，每个人依次选择一个数字，然后把这个数字第一次出现位置及其之前的数字都删掉，直到谁把序列删除空谁就赢了，
   niuniu先手，niumei后手，谁赢打印谁的名字。

   ```
   输入：
   T 表示有几组数据
   n 表示每组序列中有几个数
   ***** 接下来一行为序列

   样例：
   	1
   	6
   	111222
   输出：
   	niuniu
   原因：niuniu选2，序列变为22；niumei选2，序列变为2；niuniu选2，序列变为空，niuniu赢
   ```

   ```
   分析：有点像博弈论：每个人每次操作都必须保证自己能赢（而不是乱操作）

   两个人每次选择一个数 x，就会删除 x 出现的第一次及其前面的数。
   既然会删除 x 前面的所有数，为了能够保证赢，就应该从最后开始。
   如果最后一个 x 只有一个，那么 niu 选择这个 x 之后，就会清除整个序列，niu 赢。更广义来说，如果最后的 x 是奇数个，则 niu 选择这个 x 之后就都能赢。

   如果最后一个 x 只有两个，那么 niu 选择这个 x 之后，整个序列就只会剩下一个 x 了，此时 mei 选择这个 x 就赢了，因此 niu 不能选这个 x，而是应该向前查找。更广义的说，如果最后的 x 是偶数个，那么每个人都不能选择这个 x。

   因此，从后向前，只要找到奇数个 x 时，就能够保证当前操作者赢。
   就当前题目而言，只要序列中有奇数个 x 就能保证 niu 赢，如果全部都是偶数个 x，则 mei 赢。
   ```

2. 有个藏宝架有n层，每层的宝物数量不一，每个宝物都有其价值，现在要求拿出m个宝物，并且需要遵守规则：

   1. 每次只能拿选定层的两端的宝物之一
   2. 要拿出的m个宝物的总价值是各种方案里最大的 

   ```
   输入：
   	n m：下面每行代表每层，且第一个数是这层宝物的数量k，后面的则是k个宝物的价值
   	4 1 2 4 5
   	5 1 2 4 5 5

   样例：
   	2 3
   	2 3 2
   	4 1 4 1 5

   输出：
   	5+3+2=10
   	
   n和c最大为100，m最大为10000，说明如果m >= n * c，所有物品都可以拿走，所以每一层如果已经拿了第1个和第c个，那就还可以继续拿第2个和第c-1个。
   ```

   ```
   1 步：a
   i -> max

   2 步：b
   i,j -> max
   i,i-1 -> max

   3 步：c
   i,j,k
   i,i-1,k
   i,j,j-1
   i,i-1,i-2

   4 步：d
   i,j,k,n
   i,j,k,k-1

   i,i-1,k,n
   i,i-1,k,k-1

   i,j,j-1,n
   i,j,j-1,j-2

   i,i-1,i-2,n
   i,i-1,i-2,i-3

   选定一个 max
   则要么是 max，maxOther 要么是 max，max-1

   maxOther 和 max-1 其实就是找两个的 max
   当前 i 并不一定是最大的，可能 i - 1 才是最大的，但是怎么才能忽略 i 而去找 i - 1 呢？
   走 i 步：遍历第 i 层
   ```

   ​

3. 注意点：

   ```
   1. 注意取值范围：使用 int 还是 long
   2. 尽量跑起来，或许能过一个 case 呢
   3. 想不出来就最简单暴力的方法，或许能够通过一个测试用例呢？
   4. 想不出来，哪怕思路错了也要写出来，这个面试官是要看的，并且哪怕通过了一个 case 呢？
   ```

   ​