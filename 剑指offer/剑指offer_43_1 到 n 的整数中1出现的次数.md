#### 【剑指offer_43_1~n整数中1出现的次数】

+ 题目描述

  ```text
  求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
  ```

+ 解析

  ```java
  /*
  【理解1】
  任何一个数 num 可以将其作为各个位数的数相加的结果：1998=1000+900+90+8
  有：数 num 中 1出现的次数就等于各个位数的数中 1 出现的次数之和！
  
  【理解2】
  找规律：
  	0~9：	1——1次
  	0~99：	1——20次
  	0~999：	1——300次
  	...		...
  验证：以 0~9 为基础 1 只会出现 1 次
    0~99的数中：
  	0~9 出现 10 次：故 1 出现 10*1 次
  	存在十位上为 1 ：故 1 出现 10 次
  	所以：0~99 中 1 总共出现 10*1+10=20 次
    0~99的数中：【同理】
  	0~99 出现 10 次：故 1 出现 10*20 次
  	存在百位上位 1 ：故 1 出现 100 次
  	所以：0~999 中 1 总共出现 10*20+100=300 次
  公式总结：
  	0~10^n-1 中 1 出现的次数 count = n * 10^(n-1)
  	0~10^n 中 1 出现的次数 count = n * 10^(n-1) + 1
  【特殊】当 n=0 时，即 0< num <10
  	若 10> num >= 1 : count =1
      若 num = 0 :count = 0
  */
  ```

+ 解决

  ```java
  /*
  由 【理解1】 可以将数 num 以10进制位，从各位开始，按位计算 1 出现的次数，再累加！
  例：
  	num = 1998 = 1000+900+90+8
  对于任意一个进制位代表的数 a：
  	a = k * 10^n	( 90 = 9 * 10^1 )
      讨论1 ：出现 0 ~ 10^n-1 的次数
          k 次 0 ~ 10^n-1（如 90 会出现：9 次 0~9 ）
      讨论2 ：该位上的数字是否 出现 1，即 k 与 1 做比较（两种情况）
          1、k > 1
              count = k * n * 10^(n-1) + 10^n * 1  
              count = [ k 次 0~10^n-1 个 1 ] + [ 10^n 个 1 ]
              90 = [ 9 次 0~9 ] + [ 10~19 中出现的十位上的 10 个 1] 
          2、k = 1
              count = ( n * 10^(n-1) + 1 ) + m 
              m 表示的 该位上的 1 出现多少次
              例如：1998 = 1000+900+90+8 中拆分的 千位上的数为 1000，此时 k = 1 ，说明从 1000~1998 之间出现 998 个4位数，这些数的千位上为 1 （ m = 998 ）
              所以 count = [ 1 次 0~999 ]+[ 998 次 千位上为 1 ]
  */
  ```

+ 代码

  ```java
  public static int NumberOf1Between1AndN_Solution(int n) {
      // 记录 10的幂次
      int k = 0;
      // 记录 类似于 1000 ~ 1998 上有 998 个 千位上为 1 的总数
      int m;
      // 剩下未遍历的数（按10进制位，从各位开始遍历）
      int rest = n;
      // 遍历的 各个位上的 k
      int temp;
      // 1 的总数
      int sum = 0;
      // 10^n 次
      int grade = 1;
      while (rest > 0) {
          // 获取 十进制位 的各个位数
          temp = rest % 10;
          if (temp > 1) {
               // 情况 1
              sum += (temp * k * grade / 10 + grade * 1);
          } else if (temp == 1) {
              // 情况 2
              sum += (k * grade / 10 + 1);
              m = n % grade;
              if (m != 0) {
                  // 该位上 出现 m 个 1
                  sum += m;
              }
          }
          
          // 为遍历下一位做准备！
          rest /= 10;
          k++;
          grade *= 10;
      }
      return sum;
  }
  ```

  