##### 股票交易日

###### 题目描述

+ 在股市的交易日中，假设最多可进行两次买卖(即买和卖的次数均小于等于2)，规则是必须一笔成交后进行另一笔(即买-卖-买-卖的顺序进行)。给出一天中的股票变化序列，请写一个程序计算一天可以获得的最大收益。请采用时间复杂度低的方法实现。

###### 输入描述

```
给定价格序列 prices 及它的长度 n
```

###### 输出描述

```
返回最大收益。保证长度小于等于500。
```

##### 示例

###### 输入

```
[10,22,5,75,65,80],6
```

###### 输出

```
87
```

##### 题解：动态规划

+ 该题有两次买入卖出的机会，并且必须是连续的，因此如果是两次买入卖出的结果之和，就需要以某个数作为中间值！

  + 在该值之前 买入卖出：达到最大值！
  + 在该值之后 买入卖出：达到最大值！

  **因此，利润最大化为`max(A_前买卖 + A_后买卖, 其他位置之前或者之后买入卖出)`**

  *注意：*

  + 如果最大值为 负数，则应该使用 0 代替！

+ 代码：

  ```java
  public int maxProfit(int[] arr, int n) {
      // dp[i] ：位置 i 之前能得到的最大收益
      int[] dpFront=new int[n];
      // 从头开始，第一个位置只有一个 数，收益为 0
      dpFront[0]=0;
      // 记录 i 之前的最小值
      int min=arr[0];
      for(int i=1;i<n;++i){
          // 对于位置 i，最大收益要么是当前结点，如果不是，则应该是上一个结点的状态！
          dpFront[i]= Math.max(dpFront[i-1],arr[i]-min);
          if(min>arr[i]){
              // 更新最小值
              min=arr[i];
          }
      }
          
      // dp[i] ：位置 i 之后能够得到的最大收益
      int[] dpEnd=new int[n];
      // 从尾开始，最后一个位置只有一个数，收益为 0
      dpEnd[n-1]=0;
      // 记录 i 之后的最大值（从后往前遍历：max - arr[i]：减数在后，被减数在前）
      int max=arr[n-1];
      for(int i=n-2;i>=0;--i){
          // 对于位置 i，最大收益要么是当前结点，如果不是，则应该是上一个结点的状态！
          dpEnd[i]=Math.max(dpEnd[i+1],max-arr[i]);
          if(max<arr[i]){
              // 更新最大值
              max=arr[i];
          }
      }
      int maxSub=0;
      for(int i=0;i<n;++i){
          // maxSub=max(i_之前 + i_之后, maxSub);
          maxSub=Math.max(dpEnd[i]+dpFront[i],maxSub);
      }
      return maxSub;
  }
  ```

##### 相似题：股票的最大利润

+ 题目描述

  ```
  假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润？
  ```

+ 例如输入：

  ```
  {9, 11, 8, 5, 7, 12, 16, 14}
  ```

+ 输出

  ```
  11
  ```

+ **思路：动态规划**

  ```
  dp[i] : 第 i 个数之前的最小值
  dp[i] = min(dp[i-1],arr[i]);
  ```

  

