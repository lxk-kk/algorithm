#### 一、回文数索引

##### 1. 题目

###### 题目描述

+ 给定一个仅由小写字母组成的字符串。现在请找出一个位置，删掉那个字母之后，字符串变成回文。请放心总会有一个合法的解。如果给定的字符串已经是一个回文串，那么输出-1。

###### 输入描述

```
第一行包含T，测试数据的组数。后面跟有T行，每行包含一个字符串。
```

###### 输出描述

```
如果可以删去一个字母使它变成回文串，则输出任意一个满足条件的删去字母的位置（下标从0开始）。
例如： bcc 我们可以删掉位置0的b字符。
```

##### 2. 示例

###### 输入

```
3
aaab
baa
aaa
```

###### 输出

```
3
0
-1
```

##### 3. 题解

###### 首尾指针法

+ **首尾指针：向中间靠拢**，一旦遇到不相符的字符说明这两个字符之中一定有一个是多余的字符。此时，随意选择其中一个字符舍去，判断剩下的是否能够形成回文：

  + 如果剩下的子串能形成回文，则说明舍弃正确！
  + 如果不能则说明舍弃错误，需要舍弃另外一个！

+ 代码：

  ```java
  private static int findIdx(String str) {
      int temp = 0;
      boolean judge = false;
      // 首尾指针
      int st = 0;
      int end = str.length() - 1;
      while (st < end) {
          if (str.charAt(st) == str.charAt(end)) {
              st++;
              end--;
          } else if (!judge) {
              // 第一次：左右不相等的字符
              judge = true;
              // 由于对称性，只需要记录其中一个字符的下标即可！
              temp = st;
              // 舍弃左边的字符（也可以舍弃右边的字符）
              st++;
          } else if (judge) {
              // 第二次不相等：说明前一次字符舍弃错误，此时可以直接返回未舍弃的字符的下标
              // 通过对称性即可获知未舍弃的字符的下标
              return str.length() - 1 - temp;
          }
      }
      // 到此时有两种情况：
      // 1： 该字符串本身就是回文串，并没有出现左右不相等的情况。
      // 2： 出现过一次左右不相等的字符串，并且舍弃的字符正确
      return judge ? temp : -1;
  }
  ```

#### 二、回文子串

##### 1. 题目

###### 题目描述

+ 给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

  具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

##### 2. 示例

###### 输入

```
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"

输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

+ 提示：

  输入的字符串长度不会超过 1000 。

##### 3. 题解

###### (1) 动态规划

+ **dp\[i][j] ：i，j 之间的字符子串是否为回文串**（1：回文串，0 不是回文串）

+ 子问题

  **i,j 子串是回文串**  => **i+1,j-1 子串一定也是回文串！**

+ 递推式：

  ```
   1. dp[i][j] = 1
   	i ==j || (j==i+1 && char(i)==char(j)) || (char(i)==char(j) && dp[i+1][j-1] == 1)
   	
   2. dp[i][j] = 0
   	上述情况之外！
  ```

+ 代码：

  ```java
  class Solution {
      public int countSubstrings(String s) {
          boolean[][] dp = new boolean[s.length()][s.length()];
          int count = 0;
          for(int step = 0; step < s.length(); ++step){
              for(int i = 0; i + step < s.length(); ++i){
                  int j = i + step;
                  if(i == j 
                     || i + 1 == j && s.charAt(i) == s.charAt(j) 
                     || dp[i+1][j-1] && s.charAt(i) == s.charAt(j) ){
                      
                      dp[i][j] = true;
                  }
                  if(dp[i][j]){
                      count++;
                  }
              }
          }
          return count;
      }
  }
  ```

+ 复杂度

  ```
  空间：O(n^2)
  时间：O(n^2)
  ```

+ 结果

  ```
  执行用时：13 ms 在所有 Java 提交中击败了 42.06% 的用户
  内存消耗：40.1 MB 在所有 Java 提交中击败了 19.58% 的用户
  ```

  

###### (2) 回文中间点探测

+ 思路：

  根据回文串的特性，遍历每一个可能的回文子串：

  1. 单个字符一定是回文子串

  2. 双字符，当两个字符相等，则是回文子串

  3. 如果字符串是回文子串，则如果"子串前一个字符 == 子串后一个字符"，则构成新回文子串

     在新回文子串的基础上，重复 3 操作！

+ 代码

  ```java
  class Solution {
      public int countSubstrings(String s) {
         int count = 0;
         int k;
         for(int i = 0; i < s.length(); ++i){
             // 起始单字符：左右摆动探测
             k = 0;
             while(i - k >= 0 && i + k < s.length() && s.charAt(i-k) == s.charAt(i+k)){
                 k++;
             }
             count+=k;
             
             // 起始双字符：左右摆动探测
             k = 0;
             while(i-k >=0 && i + 1 + k < s.length() && s.charAt(i-k) == s.charAt(i+1+k)){
                 k++;
             }
             count+=k;
         }
         return count;
      }
  }
  ```

+ 复杂读

  ```
  空间：O(1)
  时间：O(n^2)
  ```

+ 结果

  ```
  执行用时：5 ms 在所有 Java 提交中击败了 61.66% 的用户
  内存消耗：37.6 MB 在所有 Java 提交中击败了 90.25% 的用户
  ```

#### 题目延申

+ 求字符串中的最长回文子串！！！