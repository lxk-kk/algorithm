#### 回文数索引

##### 题目

###### 题目描述

+ 给定一个仅由小写字母组成的字符串。现在请找出一个位置，删掉那个字母之后，字符串变成回文。请放心总会有一个合法的解。如果给定的字符串已经是一个回文串，那么输出-1。

###### 输入描述

```
第一行包含T，测试数据的组数。后面跟有T行，每行包含一个字符串。
```

###### 输出描述

```
如果可以删去一个字母使它变成回文串，则输出任意一个满足条件的删去字母的位置（下标从0开始）。
例如： bcc 我们可以删掉位置0的b字符。
```

##### 示例

###### 输入

```
3
aaab
baa
aaa
```

###### 输出

```
3
0
-1
```

##### 题解

###### 首尾指针法

+ **首尾指针：向中间靠拢**，一旦遇到不相符的字符说明这两个字符之中一定有一个是多余的字符。此时，随意选择其中一个字符舍去，判断剩下的是否能够形成回文：

  + 如果剩下的子串能形成回文，则说明舍弃正确！
  + 如果不能则说明舍弃错误，需要舍弃另外一个！

+ 代码：

  ```java
  private static int findIdx(String str) {
      int temp = 0;
      boolean judge = false;
      // 首尾指针
      int st = 0;
      int end = str.length() - 1;
      while (st < end) {
          if (str.charAt(st) == str.charAt(end)) {
              st++;
              end--;
          } else if (!judge) {
              // 第一次：左右不相等的字符
              judge = true;
              // 由于对称性，只需要记录其中一个字符的下标即可！
              temp = st;
              // 舍弃左边的字符（也可以舍弃右边的字符）
              st++;
          } else if (judge) {
              // 第二次不相等：说明前一次字符舍弃错误，此时可以直接返回未舍弃的字符的下标
              // 通过对称性即可获知未舍弃的字符的下标
              return str.length() - 1 - temp;
          }
      }
      // 到此时有两种情况：
      // 1： 该字符串本身就是回文串，并没有出现左右不相等的情况。
      // 2： 出现过一次左右不相等的字符串，并且舍弃的字符正确
      return judge ? temp : -1;
  }
  ```
  
  
  
  
